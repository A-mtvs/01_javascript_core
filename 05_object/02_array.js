/*
# 문법 설명
1. 배열은 `[요소1, 요소2, ...]` 형태로 선언하며, 다양한 데이터 타입을 저장할 수 있다.
2. `push`, `pop`, `unshift`, `shift` 메서드를 통해 배열의 요소를 추가하거나 제거할 수 있다.
3. `forEach`는 배열을 순회하며, 각 요소에 대해 작업을 수행한다.
4. `map`은 배열을 순회하며 새로운 배열을 반환한다.
*/

/*
# 스토리
한 가게에서 판매되는 과일 목록을 관리하고, 판매된 과일 정보를 추적한다. 
배열을 사용해 과일을 추가하거나 제거하고, 판매된 과일의 개수를 집계한다.
*/

/*
# 1. 배열 생성과 기본 메서드 활용
과일 목록을 배열로 선언하고, 추가 및 제거 작업을 수행한다.
*/
let fruits = ["사과", "바나나", "포도"];

console.log(`초기 과일 목록: ${fruits}`);

// 과일 추가
fruits.push("귤");
console.log(`귤 추가 후: ${fruits}`);

// 과일 제거
fruits.pop();
console.log(`마지막 과일 제거 후: ${fruits}`);

/*
결과 설명
- 배열에 요소를 동적으로 추가하거나 제거할 수 있다.
- `push`는 배열 끝에 요소를 추가하고, `pop`은 배열 끝 요소를 제거한다.
*/




/*
# 2. 배열 순회
판매된 과일을 배열로 관리하고, 각 판매량을 출력한다.
*/
const soldFruits = ["사과", "바나나", "사과", "포도", "사과"];

console.log("판매된 과일 목록:");
soldFruits.forEach((fruit) => console.log(fruit));

/*
결과 설명
- `forEach` 메서드를 사용해 배열의 각 요소를 순회하며 작업 수행.
- 배열의 모든 요소를 출력하거나 특정 로직을 적용할 수 있다.
*/




/*
# 3. 배열 변환
판매된 과일 목록에서 과일별 판매량을 계산한다.
*/
const fruitCounts = soldFruits.reduce((count, fruit) => {
    count[fruit] = (count[fruit] || 0) + 1;
    return count;
}, {});

console.log("과일별 판매량:", fruitCounts);

/*
결과 설명
- `reduce` 메서드를 사용해 배열의 데이터를 객체로 변환.
- 과일별로 판매량을 집계하여 객체 형태로 저장.
*/





/*
# 4. 다차원 배열
가게의 각 카운터에서 판매된 과일 정보를 다차원 배열로 저장하고, 이를 처리한다.
*/
const counters = [    ["사과", "바나나"],
    ["포도", "사과"],
    ["바나나", "귤"]
];

// 모든 카운터의 과일 목록을 하나의 배열로 병합
const allSoldFruits = counters.flat();
console.log("병합된 과일 목록:", allSoldFruits);

/*
결과 설명
- 다차원 배열을 사용해 각 카운터의 정보를 저장.
- `flat` 메서드를 사용해 중첩 배열을 단일 배열로 변환.
*/



/*
결론
1. 배열은 데이터를 순차적으로 저장하고 관리하는 데 유용하다.
2. 다양한 메서드를 활용해 배열의 요소를 조작하거나 데이터를 변환할 수 있다.
3. 다차원 배열을 사용해 복잡한 데이터를 구조화하고, 이를 효율적으로 처리 가능.
*/
